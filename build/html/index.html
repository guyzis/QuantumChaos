
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Welcome to QuantumChaos’s documentation! &#8212; QuantumChaos v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/nature.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]]}})</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">QuantumChaos v1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Welcome to QuantumChaos’s documentation!</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="welcome-to-quantumchaos-s-documentation">
<h1>Welcome to QuantumChaos’s documentation!<a class="headerlink" href="#welcome-to-quantumchaos-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<p>This project contains samples of the code used to write the following articles:</p>
<ul class="simple">
<li><p>Guy Zisling, Lea F. Santos, and Yevgeny Bar Lev, <strong>How many particles make up a chaotic many-body quantum system?</strong> <a class="reference external" href="https://doi.org/10.21468/SciPostPhys.10.4.088">SciPost Phys. 10, 88 (2021)</a>.</p></li>
<li><p>Guy Zisling, Dante M. Kennes, and Yevegeny Bar Lev, <strong>Transport in Stark Many Body Localized Systems</strong> <a class="reference external" href="https://arxiv.org/abs/2109.06196">arXiv:2109.06196</a>.</p></li>
</ul>
<p><strong>The code can be used for two main purposes:</strong></p>
<ol class="arabic simple">
<li><p>Build Hamiltonian’s (matrix representations) of spin-chain systems (mainly “XXZ” chain).</p></li>
<li><p>Examine the statical and dynamical properties of those Hamiltonian’s.</p></li>
</ol>
<p><strong>Link to the github repo:</strong></p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/guyzis/QuantumChaos">https://github.com/guyzis/QuantumChaos</a></p>
</div></blockquote>
<p><em>All the code was written by Guy Zisling</em></p>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</section>
<section id="math-intro">
<h1>Math Intro<a class="headerlink" href="#math-intro" title="Permalink to this headline">¶</a></h1>
<p>The “XXZ” chain can be written in terms of spin matrices using
<div class="math notranslate nohighlight">
\[\hat{H}=\sum_{j=1}^{L-1}\frac{J_{xy}}{2}\left(\hat{S}_{j}^{+}\hat{S}_{j+1}^{-} + \hat{S}_{j}^{-}\hat{S}_{j+1}^{+}\right)+J_{z}\hat{S}_{j}^{z}\hat{S}_{j+1}^{z},\]</div>

where <span class="math notranslate nohighlight">\(\hat{S}^{\{x,y,z\}}\)</span> are the Pauli matrices times a factor of <span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>.</p>
<p>Usually, this type of systems can be <strong>classified into two distinct classes</strong>:</p>
<ol class="arabic simple">
<li><p>Many-body localized systems (MBL).</p></li>
<li><p>Quantum Chaotic systems (thermalizing systems).</p></li>
</ol>
<p>Some key differences are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 44%" />
<col style="width: 26%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Feature</strong></p></th>
<th class="head"><p><strong>Quantum Chaotic</strong></p></th>
<th class="head"><p><strong>Many-body Localized</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Memory of initial conditions</p></td>
<td><p>None</p></td>
<td><p>Some</p></td>
</tr>
<tr class="row-odd"><td><p>Eigenvalues</p></td>
<td><p>Correlated</p></td>
<td><p>Uncorrelated</p></td>
</tr>
<tr class="row-even"><td><p>Off-diagonal elements distribution</p></td>
<td><p>Normal</p></td>
<td><p>Sharp distribution</p></td>
</tr>
<tr class="row-odd"><td><p>Transport</p></td>
<td><p>Super-diffusive</p></td>
<td><p>Sub-diffusive</p></td>
</tr>
<tr class="row-even"><td><p>Entanglement entropy spreading</p></td>
<td><p>Power-law</p></td>
<td><p>Logarithmic</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p><strong>Static properties</strong> are usually examined by using the Hamiltonian eigen-basis, where <span class="math notranslate nohighlight">\(E_\alpha = \left\langle {\phi_\alpha}\right .\left|{\hat{H}}\right|\left .{\phi_\alpha}\right \rangle\)</span>.</p></li>
<li><p><strong>Dynamical properties</strong> are examined using the time evolution operator <span class="math notranslate nohighlight">\(\hat{U}(t)=e^{-i\hat{H}t}\)</span>.</p></li>
</ul>
</section>
<section id="module-build_hamiltonian">
<span id="building-hamiltonians"></span><h1>Building Hamiltonians<a class="headerlink" href="#module-build_hamiltonian" title="Permalink to this headline">¶</a></h1>
<p>This module uses to build matrix representations of Hamiltonians.</p>
<p>The main logic behind the code is to represent the wavefunctions at an easy computational basis (and code it as binary numbers):
<div class="math notranslate nohighlight">
\[\left|\psi\right\rangle=\left|\uparrow\downarrow\downarrow\right\rangle=\texttt{[1,0,0]}.\]</div>

We start building the Hamiltonian matrix by generating this basis (either in basis of 10 or binary numbers array). If we take for example three spins (<span class="math notranslate nohighlight">\(L=3\)</span>) and one excitation (<span class="math notranslate nohighlight">\(N=1\)</span>), we get the following basis:
<div class="math notranslate nohighlight">
\[\left\{\left|\downarrow\downarrow\uparrow\right\rangle  , \left|\downarrow\uparrow\downarrow\right\rangle  , \left|\uparrow\downarrow\downarrow\right\rangle\right\},\space \left\{\texttt{[1,0,0]}, \texttt{[0,1,0]}, \texttt{[0,0,1]} \right\} \]</div>
</p>
<blockquote>
<div><p>Now we can see how a term in the Hamiltonian operates on this wavefunction</p>
</div></blockquote>
<p><div class="math notranslate nohighlight">
\[\hat{S}^-_0\hat{S}^+_1\left|\uparrow\downarrow\downarrow\right\rangle=\left|\downarrow\uparrow\downarrow\right\rangle\]</div>

Then we could match that output with the origin <span class="math notranslate nohighlight">\(\texttt{[1,0,0]}\leftrightarrow\texttt{[0,1,0]}\)</span>, so the matrix representation of this term in this basis is:</p>
<p><div class="math notranslate nohighlight">
\[\begin{split}\hat{S}_{0}^{-}\hat{S}_{1}^{+}=\begin{array}{c|ccc}
\psi &amp; \left|\downarrow\downarrow\uparrow\right\rangle  &amp; \left|\downarrow\uparrow\downarrow\right\rangle  &amp; \left|\uparrow\downarrow\downarrow\right\rangle \\
\hline \left\langle \downarrow\downarrow\uparrow\right| &amp; 0 &amp; 0 &amp; 0\\
\left\langle \downarrow\uparrow\downarrow\right| &amp; 0 &amp; 0 &amp; 1\\
\left\langle \uparrow\downarrow\downarrow\right| &amp; 0 &amp; 0 &amp; 0
\end{array}=\left(\begin{array}{ccc}
0 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1\\
0 &amp; 0 &amp; 0
\end{array}\right)\end{split}\]</div>
</p>
<p>All matrices generated are at the size of the basis.</p>
<dl class="py function">
<dt class="sig sig-object py" id="build_hamiltonian.matt0">
<span class="sig-prename descclassname"><span class="pre">build_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">matt0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Jx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Jz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_hamiltonian.matt0" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the XXZ Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>Jx</strong> (<em>float</em>) – xx interaction strength</p></li>
<li><p><strong>Jz</strong> (<em>float</em>) – zz interaction strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of bits encoding the wave functions</p></li>
<li><p><strong>bc</strong> (<em>0</em><em> or </em><em>1</em>) – boundary conditions 0 = open, 1 = close</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>xxz chain</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_hamiltonian.matt0sz">
<span class="sig-prename descclassname"><span class="pre">build_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">matt0sz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_hamiltonian.matt0sz" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the operator <span class="math notranslate nohighlight">\(\hat{S}^z_i\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> (<em>int</em>) – location of the operator</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of wave functions, encoded in bits formation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\hat{S}^z_i\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_hamiltonian.matt_add_imp">
<span class="sig-prename descclassname"><span class="pre">build_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">matt_add_imp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_hamiltonian.matt_add_imp" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a magentic impurity at a specific site of the chain <span class="math notranslate nohighlight">\(h\hat{S}^z_{\textrm{imp}}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – existing Hamiltonian</p></li>
<li><p><strong>imp</strong> (<em>int</em>) – impurity location</p></li>
<li><p><strong>h</strong> (<em>float</em>) – impurity strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of wave functions, encoded in bits formation</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The initial Hamiltonian plus the impurity term</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_hamiltonian.matt_add_jz">
<span class="sig-prename descclassname"><span class="pre">build_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">matt_add_jz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Jz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_hamiltonian.matt_add_jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <span class="math notranslate nohighlight">\(\hat{S}^z_i\hat{S}^z_{i+1}\)</span> interaction for an existing Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – existing Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins in the chain</p></li>
<li><p><strong>Jz</strong> (<em>float</em>) – interaction strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
<li><p><strong>bc</strong> (<em>0</em><em> or </em><em>1</em>) – boundary conditions 0 = open, 1 = close</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The matrix <span class="math notranslate nohighlight">\(\hat{H}_0\)</span> with addition of <span class="math notranslate nohighlight">\(zz\)</span> interactions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="build_hamiltonian.matt_add_stark">
<span class="sig-prename descclassname"><span class="pre">build_hamiltonian.</span></span><span class="sig-name descname"><span class="pre">matt_add_stark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#build_hamiltonian.matt_add_stark" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a linear field of strength <code class="docutils literal notranslate"><span class="pre">f</span></code> to an existing Hamiltonian (stark potential).
<div class="math notranslate nohighlight">
\[\hat{H}_0\rightarrow\hat{H}_0 + \sum_{j=1}^{L}\left(\gamma j+\alpha j^{2}/L^{2}\right) \hat{S}_{j}^{z}\]</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – existing Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins in the chain</p></li>
<li><p><strong>f</strong> (<em>float</em>) – linear potential strength</p></li>
<li><p><strong>a</strong> (<em>float</em>) – curvature strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
<li><p><strong>bc</strong> (<em>0</em><em> or </em><em>1</em>) – boundary conditions 0 = open, 1 = close</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The initial Hamiltonian plus the Stark potential term</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>sparse matrix</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-utils">
<span id="utils"></span><h1>Utils<a class="headerlink" href="#module-utils" title="Permalink to this headline">¶</a></h1>
<p>For utils used in more than one module.</p>
<p>The transformation between wave-function bits and integer representation is defined as following:
<div class="math notranslate nohighlight">
\[\vec{x}\rightarrow\sum_{i=L}^1(1-x_i)\cdot 2^{L-i}=\boldsymbol{\mathrm{int}}.\]</div>
</p>
<p>See <code class="docutils literal notranslate"><span class="pre">legacy_utils</span></code> for more information about this transformation.</p>
<dl class="py function">
<dt class="sig sig-object py" id="utils.bittoint">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">bittoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.bittoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis in bits to integers (e.g <span class="math notranslate nohighlight">\(\texttt{[0,1,1]}\rightarrow\boldsymbol{4}\)</span>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>basis</strong> (<em>np.array</em>) – a list of bits that represents the spins (1 = spin pointing up, 0 = down)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an array of integers encoding the wave function</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="utils.blockex">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">blockex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">j</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.blockex" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a basis of <code class="docutils literal notranslate"><span class="pre">n</span></code> spins and <code class="docutils literal notranslate"><span class="pre">j</span></code> excitations (spins pointing up)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – number of spins in the chain</p></li>
<li><p><strong>j</strong> (<em>int</em>) – number of excitations in the basis</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>wave functions basis in bits</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="utils.ordtobit">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">ordtobit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.ordtobit" title="Permalink to this definition">¶</a></dt>
<dd><p>Integers basis to bits basis (e.g <span class="math notranslate nohighlight">\(\boldsymbol{4}\rightarrow\texttt{[0,1,1]}\)</span>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ord</strong> (<em>np.array</em>) – an array of integers that represents the spins</p></li>
<li><p><strong>n</strong> – number of spins in the chain</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of bits that represents the spins (1 = spin pointing up, 0 = down)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="utils.ptime">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">ptime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#utils.ptime" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tz</strong> (<em>float</em>) – a time.time() output</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a string with the time it took since the initial counter tz</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-dynamical_tools">
<span id="dynamical-tools"></span><h1>Dynamical Tools<a class="headerlink" href="#module-dynamical_tools" title="Permalink to this headline">¶</a></h1>
<p>The cheapest way to calculate the time evolution of some operator <span class="math notranslate nohighlight">\(\hat{O}\)</span>  is to use the ‘Dynamical Typicality’ concept (see <a class="reference external" href="https://arxiv.org/pdf/1610.08993.pdf">Ref</a>): <div class="math notranslate nohighlight">
\[\frac{1}{\mathcal{D}}\text{Tr}\hat{O}\approx\left\langle{\psi}\right .\left|{\hat{O}}\right| \left .{\psi}\right \rangle,\]</div>

and to use the Krylov time-space evolution, explained in the following <a class="reference external" href="https://www.cs.cornell.edu/cv/ResearchPDF/19ways+.pdf">Ref</a> and built in <code class="docutils literal notranslate"><span class="pre">scipy.sparse.linalg.expm_multiply</span></code>.</p>
<p>briefly, instead of diagonalizing the full matrix <span class="math notranslate nohighlight">\(\hat{H}\)</span> in order to calculate the time evolution operator <span class="math notranslate nohighlight">\(\hat{U}(t)=e^{-i \hat{H} t}\)</span>, one asses the time evolution by averaging over random states <span class="math notranslate nohighlight">\(\left| \psi (t) \right\rangle = \hat{U}(t)\left|\psi(0)\right\rangle\)</span>, without explicitly calculating <span class="math notranslate nohighlight">\(\hat{U}(t)\)</span>.</p>
<dl class="py function">
<dt class="sig sig-object py" id="dynamical_tools.entropy">
<span class="sig-prename descclassname"><span class="pre">dynamical_tools.</span></span><span class="sig-name descname"><span class="pre">entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dynamical_tools.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the entanglement entropy of a vector <code class="docutils literal notranslate"><span class="pre">v</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>np.array</em>) – vector</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins in the chain</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>entanglment entropy</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dynamical_tools.entropy_vs_time">
<span class="sig-prename descclassname"><span class="pre">dynamical_tools.</span></span><span class="sig-name descname"><span class="pre">entropy_vs_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dynamical_tools.entropy_vs_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the entanglement entropy</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>sparse matrix</em>) – Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins in the chain</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
<li><p><strong>t</strong> (<em>float</em>) – ending time of the calculation</p></li>
<li><p><strong>k</strong> (<em>int</em>) – number of point to sample in time</p></li>
<li><p><strong>dt</strong> (<em>float</em>) – time intervals for the Krylov time evolution</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[time array, entangelment entropy array]</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dynamical_tools.evol_kryl">
<span class="sig-prename descclassname"><span class="pre">dynamical_tools.</span></span><span class="sig-name descname"><span class="pre">evol_kryl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">T</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dynamical_tools.evol_kryl" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the time evolution of a vector using Krylov sub-space
<div class="math notranslate nohighlight">
\[\vec{v}(t) = e^{-i\hat{H}t}\vec{v}\]</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>sparse matrix</em>) – Hamiltonian</p></li>
<li><p><strong>v</strong> (<em>np.array</em>) – starting vector</p></li>
<li><p><strong>dt</strong> (<em>float</em>) – time interval</p></li>
<li><p><strong>T</strong> (<em>int</em>) – number of steps</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>vector</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="dynamical_tools.msd">
<span class="sig-prename descclassname"><span class="pre">dynamical_tools.</span></span><span class="sig-name descname"><span class="pre">msd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#dynamical_tools.msd" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the spins mean square displacement after a spin flip in the middle of the chain
<div class="math notranslate nohighlight">
\[G_{n}\left(t\right)=\frac{1}{\mathcal{D}}\textrm{Tr}\left[\hat{S}_{n}^{z}\left(t\right)\hat{S}_{L/2}^{z}\right]\]</div>

<div class="math notranslate nohighlight">
\[x^{2}\left(t\right)=\sum_{n}n^{2}\left(G_{n}\left(t\right)-G_{n}\left(0\right)\right)\]</div>

:param H: Hamiltonian
:type H: sparse matrix
:param n: number of spins in the chain
:type n: int
:param basis: array of numbers encoding the wave functions
:type basis: np.array
:param t: ending time of the calculation
:type t: float
:param k: number of point to sample in time
:type k: int
:param dt: time intervals for the Krylov time evolution
:type dt: float
:param seed: fix the seed
:type seed: bool</p>
<p>Returns:</p>
</dd></dl>

</section>
<section id="module-static_tools">
<span id="static-tools"></span><h1>Static Tools<a class="headerlink" href="#module-static_tools" title="Permalink to this headline">¶</a></h1>
<p>Static properties are usually examined by using the Hamiltonian eigen-basis, where</p>
<dl class="py function">
<dt class="sig sig-object py" id="static_tools.diag_elements">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">diag_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.diag_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>ETH diagonal elements test, used to plot <span class="math notranslate nohighlight">\(\left\langle {\phi_\alpha}\right .\left|{\hat{O}}\right|\left .{\phi_\alpha}\right \rangle\)</span> as function of the energy <span class="math notranslate nohighlight">\(E_\alpha\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – the Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>normalized energies (from 0 to 1), corresponding diagonal element</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.array, np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="static_tools.offdiag">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">offdiag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dw</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">de</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_unfold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.offdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>ETH for off-diagonal elements test, used to identify the chaoticity of an Hamiltonian as a function of energy.
Used to plot how close to gaussian dist are the off-diagonal elements <span class="math notranslate nohighlight">\(\hat{O}_{\alpha\beta}={\left.\left\langle
{\phi_\alpha}\right .\left|{\hat{O}}\right|\left .{\phi_\beta}\right \rangle\right.}_{\alpha\neq\beta}\)</span> as a
function of the frequency <span class="math notranslate nohighlight">\(\omega\equiv E_{\beta} - E_{\alpha}\)</span>.</p>
<p>The gaussianity test is defined as <span class="math notranslate nohighlight">\(\Gamma_{\hat{O}}\left(\omega\right)=\frac{\overline{\left|O_{
\alpha\beta}\right|^{2}}}{\overline{\left|O_{\alpha\beta}\right|}^{2}}\)</span> which is <span class="math notranslate nohighlight">\(\pi/2\)</span> for Gaussian distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> – Hamiltonian or eigenvalues and eigenvectors</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of wave functions, encoded in bits formation</p></li>
<li><p><strong>dw</strong> (<em>float</em>) – size of frequency bins</p></li>
<li><p><strong>de</strong> (<em>float</em>) – partial part of the spectrum that is being examined (from 0 to 1)</p></li>
<li><p><strong>is_unfold</strong> (<em>bool</em>) – take unfolded eigenvalues</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\omega\)</span>, <span class="math notranslate nohighlight">\(\Gamma_{\hat{O}}\left(\omega\right)\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.array, np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="static_tools.offdiag_dist">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">offdiag_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bin_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.offdiag_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>ETH for off-diagonal elements test, used to plot the distribution of the off-diagonal elements of some local
observable. return the histogram of  <span class="math notranslate nohighlight">\(\hat{O}_{\alpha\beta}={\left.\left\langle {\phi_\alpha}\right .\left|{\hat{
O}}\right|\left .{\phi_\beta}\right \rangle\right.}_{\alpha\neq\beta}\)</span> built from <code class="docutils literal notranslate"><span class="pre">e_number</span></code> of eigenstates
near the middle of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – the Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of wave functions, encoded in bits formation</p></li>
<li><p><strong>e_number</strong> (<em>int</em>) – number of eigenvalues used to calculate the</p></li>
<li><p><strong>bin_num</strong> (<em>int</em>) – number of bins for the histogram</p></li>
<li><p><strong>normed</strong> (<em>bool</em>) – normalize by the system size and Hilbert dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an array with the histogram x,y data (same number of points at each axis)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(np.array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="static_tools.offdiag_stats">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">offdiag_stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.offdiag_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>ETH for off-diagonal elements test, used to plot the distribution of the off-diagonal elements of some local
observable. return the variance and kurtosis of  <span class="math notranslate nohighlight">\(\hat{O}_{\alpha\beta}={\left.\left\langle {\phi_\alpha}\right .\left|{\hat{
O}}\right|\left .{\phi_\beta}\right \rangle\right.}_{\alpha\neq\beta}\)</span> built from <code class="docutils literal notranslate"><span class="pre">e_number</span></code> of eigenstates
near the middle of the spectrum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H0</strong> (<em>sparse matrix</em>) – the Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – array of numbers encoding the wave functions</p></li>
<li><p><strong>e_number</strong> (<em>int</em>) – number of eigenvalues used to calculate the</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>variance, kurtosis</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(float, float)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="static_tools.rfold">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">rfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.rfold" title="Permalink to this definition">¶</a></dt>
<dd><p>A chaos matrix the arises from the eigenvalues spacing statstics</p>
<p>Defining the level spacing <span class="math notranslate nohighlight">\(s_{\alpha}=E_{\alpha+1}-E_{\alpha}\)</span> one can define the ‘r-metric’ by <div class="math notranslate nohighlight">
\[r_{\alpha}=\min\left(\frac{s_{\alpha}}{s_{\alpha-1}},\frac{s_{\alpha-1}}{s_{\alpha}}\right),\]</div>

where <div class="math notranslate nohighlight">
\[\begin{split}\left\langle r\right\rangle \approx\begin{cases}
0.39 &amp; \text{Poisson dist.}\\
0.536 &amp; \text{Wigner Dyson dist.}
\end{cases}\end{split}\]</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>H</strong> (<em>np.array</em>) – matrix or eigenvalues</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\langle r \rangle\)</span></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="static_tools.unfold">
<span class="sig-prename descclassname"><span class="pre">static_tools.</span></span><span class="sig-name descname"><span class="pre">unfold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#static_tools.unfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unfolded eigenvalues (used to remove the bais of the denisity of states in the level spacing
statistics).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>np.array</em>) – a matrix or the eigenvalues of it</p></li>
<li><p><strong>cut</strong> (<em>int</em>) – how many eigenvales to cut</p></li>
<li><p><strong>normed</strong> (<em>bool</em>) – normalize the density of staes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>unfolded eigenvalues</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-legacy_utils">
<span id="legacy-utils"></span><h1>Legacy Utils<a class="headerlink" href="#module-legacy_utils" title="Permalink to this headline">¶</a></h1>
<p>Old versions of some utils, that have been replaced with a more efficient <code class="docutils literal notranslate"><span class="pre">src_code</span></code>.
This module is used for benchmarking, and educational purposes.</p>
<p>The main idea behind this module is that matrices are generating using Kronecker product  (denoted by <span class="math notranslate nohighlight">\(\otimes\)</span>), this is much less efficient but a bit easier to grasp than the methods used in <code class="docutils literal notranslate"><span class="pre">build_hamiltonian</span></code> module.</p>
<p>For example, a term can be built as follow:
<div class="math notranslate nohighlight">
\[\hat{S}^z_i = \mathbb{I}_{2^i}\otimes \hat{S}^z \otimes \mathbb{I}_{2^{L-i-1}},\]</div>

where <span class="math notranslate nohighlight">\(L\)</span> is the chain length, and <span class="math notranslate nohighlight">\(\mathbb{I}_N\)</span> is the identity matrix of dim <span class="math notranslate nohighlight">\(N\)</span>.</p>
<p>Using this method the output is the matrix representation on the ‘computational basis’,  for example for two spins (<span class="math notranslate nohighlight">\(L=2\)</span>):
<div class="math notranslate nohighlight">
\[\{\left|\uparrow\uparrow\right\rangle, \left|\uparrow\downarrow\right\rangle, \left|\downarrow\uparrow\right\rangle, \left|\downarrow\downarrow\right\rangle\}.\]</div>
</p>
<p>If we want to use only a sub-sector of the <span class="math notranslate nohighlight">\(N=2^L\)</span> matrix we need to code this basis into ordered numbers, to do so we use the following transformation
<div class="math notranslate nohighlight">
\[\left|\downarrow\uparrow\right\rangle=\texttt{[0,1]}=\sum_{i=L}^1(1-x_i)\cdot 2^{L-i}=0\cdot2^0+1\cdot2^1=\boldsymbol{2}.\]</div>
</p>
<p>For example if we want to take only the zero magnetization sector (where the same number of spins point up and down) out of the following matrix
<div class="math notranslate nohighlight">
\[\begin{split}\hat{S}_{1}^{z}=\mathbb{I}_{2}\otimes\hat{S}^{z}=\left(\begin{array}{cccc}
0.5 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; -0.5 &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 0.5 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; -0.5
\end{array}\right)\end{split}\]</div>
</p>
<p>We need to cut the following entries
<div class="math notranslate nohighlight">
\[\{\left|\uparrow\downarrow\right\rangle, \left|\downarrow\uparrow\right\rangle\}=\{\boldsymbol{1}, \boldsymbol{2}\},\]</div>
</p>
<p>so the matrix representation in this basis would be</p>
<p><div class="math notranslate nohighlight">
\[\begin{split}\hat{S}_{1,\mathrm{basis}}^{z}=\left(\begin{array}{cc}
-0.5 &amp; 0\\
0 &amp; 0.5
\end{array}\right)\end{split}\]</div>
</p>
<dl class="py function">
<dt class="sig sig-object py" id="legacy_utils.outerr">
<span class="sig-prename descclassname"><span class="pre">legacy_utils.</span></span><span class="sig-name descname"><span class="pre">outerr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#legacy_utils.outerr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate an <span class="math notranslate nohighlight">\(2^n\)</span> dim matrix representing matrix <code class="docutils literal notranslate"><span class="pre">a</span></code> in place <code class="docutils literal notranslate"><span class="pre">i</span></code> in the full hilbert space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>np.array</em>) – matrix</p></li>
<li><p><strong>i</strong> (<em>int</em>) – location in the spin chain</p></li>
<li><p><strong>n</strong> (<em>int</em>) – spin chain length</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\hat{a}_i\)</span> <span class="math notranslate nohighlight">\(2^n      imes2^n\)</span> matrix repreesntation</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="legacy_utils.xxz_block_add_imp">
<span class="sig-prename descclassname"><span class="pre">legacy_utils.</span></span><span class="sig-name descname"><span class="pre">xxz_block_add_imp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#legacy_utils.xxz_block_add_imp" title="Permalink to this definition">¶</a></dt>
<dd><p>Add impurity to existing Hamiltonian <span class="math notranslate nohighlight">\(\hat{H}\rightarrow \hat{H} + h\cdot\hat{S}^z_{\mathrm{imp}}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>np.array</em>) – initial Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>imp</strong> (<em>int</em>) – impurity location</p></li>
<li><p><strong>h</strong> (<em>float</em>) – impurity strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – an array encoding the wave functions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Hamiltonian matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> plus the impurity term.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="legacy_utils.xxz_block_add_stark">
<span class="sig-prename descclassname"><span class="pre">legacy_utils.</span></span><span class="sig-name descname"><span class="pre">xxz_block_add_stark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#legacy_utils.xxz_block_add_stark" title="Permalink to this definition">¶</a></dt>
<dd><p>Add Stark potential to existing Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>H</strong> (<em>np.array</em>) – initial Hamiltonian</p></li>
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>f</strong> (<em>float</em>) – linear potential strength</p></li>
<li><p><strong>a</strong> (<em>float</em>) – curvature strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – an array encoding the wave functions</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Hamiltonian matrix <code class="docutils literal notranslate"><span class="pre">H</span></code> plus the Stark potential</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="legacy_utils.xxz_block_stark">
<span class="sig-prename descclassname"><span class="pre">legacy_utils.</span></span><span class="sig-name descname"><span class="pre">xxz_block_stark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Jx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Jz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#legacy_utils.xxz_block_stark" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Stark Hamiltonian (xxz chain with linear potential)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – number of spins</p></li>
<li><p><strong>Jx</strong> (<em>float</em>) – xx interaction strength</p></li>
<li><p><strong>Jz</strong> (<em>float</em>) – zz interaction strength</p></li>
<li><p><strong>f</strong> (<em>float</em>) – linear potential strength</p></li>
<li><p><strong>a</strong> (<em>float</em>) – curvature strength</p></li>
<li><p><strong>basis</strong> (<em>np.array</em>) – an array encoding the wave functions</p></li>
<li><p><strong>bc</strong> (<em>int</em>) – boundary conditions (0 - open, 1 - closed)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the Stark Hamiltonian matrix representation on the basis given</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-unit_test">
<span id="unit-test"></span><h1>Unit Test<a class="headerlink" href="#module-unit_test" title="Permalink to this headline">¶</a></h1>
<p>Test module, to use it run
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">-m</span> <span class="pre">unittest</span> <span class="pre">-v</span> <span class="pre">src_code.unit_test.Test</span></code></p>
<dl class="py class">
<dt class="sig sig-object py" id="unit_test.Test">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">unit_test.</span></span><span class="sig-name descname"><span class="pre">Test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">methodName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'runTest'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.setUpClass">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">setUpClass</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.setUpClass" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize variables, creates XXZ matrices for benchmarking, diagonalize the matrices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_diag_elements">
<span class="sig-name descname"><span class="pre">test_diag_elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_diag_elements" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure diag_elements runs properly and returns a tuple</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_impurity">
<span class="sig-name descname"><span class="pre">test_impurity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_impurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Benchmark the addition of impurity</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_msd">
<span class="sig-name descname"><span class="pre">test_msd</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_msd" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure msd functions runs properly and return a tuple</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_offdiag">
<span class="sig-name descname"><span class="pre">test_offdiag</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_offdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure offdiag runs properly and returns a tuple</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_offdiag_dist">
<span class="sig-name descname"><span class="pre">test_offdiag_dist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_offdiag_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure offdiag_dist runs properly and returns an np.array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_rfold">
<span class="sig-name descname"><span class="pre">test_rfold</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_rfold" title="Permalink to this definition">¶</a></dt>
<dd><p>Make sure rfold is runs properly and returns a float</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_stark">
<span class="sig-name descname"><span class="pre">test_stark</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_stark" title="Permalink to this definition">¶</a></dt>
<dd><p>Benchmark the <cite>Stark</cite> potentials</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="unit_test.Test.test_xxz">
<span class="sig-name descname"><span class="pre">test_xxz</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#unit_test.Test.test_xxz" title="Permalink to this definition">¶</a></dt>
<dd><p>Benchmark the basic XXZ matrices</p>
</dd></dl>

</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to QuantumChaos’s documentation!</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
<li><a class="reference internal" href="#math-intro">Math Intro</a></li>
<li><a class="reference internal" href="#module-build_hamiltonian">Building Hamiltonians</a></li>
<li><a class="reference internal" href="#module-utils">Utils</a></li>
<li><a class="reference internal" href="#module-dynamical_tools">Dynamical Tools</a></li>
<li><a class="reference internal" href="#module-static_tools">Static Tools</a></li>
<li><a class="reference internal" href="#module-legacy_utils">Legacy Utils</a></li>
<li><a class="reference internal" href="#module-unit_test">Unit Test</a></li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="#">QuantumChaos v1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Welcome to QuantumChaos’s documentation!</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Guy Zisling.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.2.0.
    </div>
  </body>
</html>